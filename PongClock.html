<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pong Game with Paddle Reflection</title>
<style>
  body {
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #000;
  }
  canvas {
    border: 3px solid #fff;
  }
  @font-face {
    font-family: 'ScoreFont';
    src: url('score.ttf') format('truetype');
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600" style="background-color: #333;"></canvas>
<script>
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
function generateSquareWaveAudio(context, duration, frequency) {
    const sampleRate = context.sampleRate;
    const samples = duration * sampleRate;
    const buffer = context.createBuffer(1, samples, sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < samples; i++) {
        data[i] = (i % (sampleRate / (2 * frequency))) < (sampleRate / (4 * frequency)) ? 1 : -1;
    }
    return buffer;
}
function getCurrentTime() {
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes();
    const seconds = now.getSeconds();
    return {
        hours,
        minutes,
        seconds
    };
}
const scoreSquareWaveBuffer = generateSquareWaveAudio(audioContext, 0.25, 40);
const bounceSquareWaveBuffer = generateSquareWaveAudio(audioContext, 0.01, 100);
function playBounceSound() {
    const bounceSource = audioContext.createBufferSource();
    bounceSource.buffer = bounceSquareWaveBuffer;
    bounceSource.connect(audioContext.destination);
    bounceSource.start();
}
function Points(difference) {
    if (difference > 7) {
        return 8;
    } else if (difference > 4) {
        return 5;
    } else if (difference > 2) {
        return 3;
    } else if (difference > 1) {
        return 2;
    } else {
        return 1;
    }
}

function playScoreSound() {
    const scoreSource = audioContext.createBufferSource();
    scoreSource.buffer = scoreSquareWaveBuffer;
    scoreSource.connect(audioContext.destination);
    scoreSource.start();
}
let lastPlayer;
class Paddle {
    constructor(x, canvasHeight, controlMode = 0) {
        this.canvasHeight = canvasHeight;
        this.x = x;
        this.y = canvasHeight / 2;
        this.width = 15;
        this.height = 100;
        this.trackDistanceX = 150;
        this.trackDistanceY = 50;
        this.speedIncrement = 0.5;
        this.speedCap = 20;
        this.speed = 5;
        this.controlMode = controlMode;
        this.lastPlayer = 10;
        this.targetY = null;
    }
    update(ball) {
        this.speed += this.speedIncrement;
        if (this.y + this.height / 2 < ball.y) {
            this.y += this.speed;
        } else if (this.y + this.height / 2 > ball.y) {
            this.y -= this.speed;
        }
        this.y = Math.max(this.y, 0);
        this.y = Math.min(this.y, this.canvasHeight - this.height);
    }
    draw(ctx) {
        ctx.fillStyle = '#FFF';
        ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
    }
    updateControlMode(currentHour, currentMinute, currentSecond, player1Score, player2Score) {
        this.controlMode = 0;
        if ((currentMinute === 59 && currentSecond >= 55) || (currentHour > player1Score)) {
            this.controlMode = 1;
        }
        if ((currentMinute > player2Score && currentSecond >= 55) || (currentMinute > player2Score)) {
            // Calculate the control mode based on the described logic
            if (this.controlMode === 1) {
                const dividedSeconds = Math.floor(currentSecond / 5);
                this.controlMode = dividedSeconds % 2 === 0 ? 2 : 1;
            } else {
                this.controlMode = 2;
            }
        }
    }
    predictBallPosition(ball) {
        const opponentPaddle = (ball.velocityX > 0) ? playerTwo : playerOne;
        const distanceX = Math.abs(ball.x - this.x);
        const distanceY = Math.abs(ball.y - this.y);
        if (distanceX < this.trackDistanceX && distanceY > this.trackDistanceY) {
            const targetY = ball.y + (this.x - ball.x) * (ball.velocityY / ball.velocityX);
            this.moveToPosition(targetY);
        } else {
            if (this.lastPlayer !== (ball.velocityX > 0)) {
                this.lastPlayer = (ball.velocityX > 0);
                this.speed += this.speedIncrement;
                opponentPaddle.targetY = (Math.random() * (opponentPaddle.height)) - (opponentPaddle.height / 2);
            }
            let ballCurrentX = ball.x;
            let ballCurrentY = ball.y;
            let ballVelocityY = ball.velocityY;
            const deltaX = ball.velocityX > 0 ? 1 : -1;
            while ((ballCurrentX > 0 && ballCurrentX < canvas.width) && (ballCurrentX !== this.x)) {
                ballCurrentX += deltaX;
                ballCurrentY += ballVelocityY * deltaX / Math.abs(ball.velocityX);
                if (ballCurrentY < 0 || ballCurrentY > canvas.height) {
                    ballVelocityY = -ballVelocityY;
                    ballCurrentY += ballVelocityY * deltaX / Math.abs(ball.velocityX);
                }
            }
            let ballBlockY = ballCurrentY;
            if (this.controlMode === 1 && opponentPaddle === playerTwo) {
                ballBlockY = (600 - ballCurrentY);
            }
            if (this.controlMode === 2 && opponentPaddle === playerOne) {
                ballBlockY = (600 - ballCurrentY);
            }
            opponentPaddle.moveToPosition(ballBlockY - opponentPaddle.targetY);
        }
    }
    moveToPosition(yPosition) {
        let direction = yPosition - this.y;
        if (direction > this.speed) {
            this.y += this.speed;
        } else if (direction < -this.speed) {
            this.y -= this.speed;
        } else {
            this.y = yPosition;
        }
        this.y = Math.max(this.y, 50);
        this.y = Math.min(this.y, this.canvasHeight - this.height + 50);
    }
}
const squareWaveBuffer = generateSquareWaveAudio(audioContext, 0.01, 440);
const source = audioContext.createBufferSource();
source.buffer = squareWaveBuffer;
source.connect(audioContext.destination);
class Ball {
    constructor(canvasWidth, canvasHeight, audioContext, source) {
        this.canvasWidth = canvasWidth;
        this.canvasHeight = canvasHeight;
        this.audioContext = audioContext;
        this.audioSource = source;
        this.reset();
        this.speedIncrement = 0.5;
        this.speedCap = 16;
        this.speed = 4;
    }
    reset() {
        this.x = this.canvasWidth / 2;
        this.y = this.canvasHeight / 2;
        this.radius = 10;
        this.speed = 4;
        this.velocityX = this.speed * (Math.random() > 0.5 ? 1 : -1);
        this.velocityY = this.speed * (Math.random() > 0.5 ? 1 : -1);
    }
    playSquareWave() {
        const squareWaveSource = this.audioContext.createBufferSource();
        squareWaveSource.buffer = squareWaveBuffer;
        squareWaveSource.connect(this.audioContext.destination);
        squareWaveSource.start();
    }
    update(paddles) {
        this.x += this.velocityX;
        this.y += this.velocityY;
        if (this.y - this.radius < 0) {
            this.y = this.radius;
            this.velocityY = Math.abs(this.velocityY);
            playBounceSound();
        } else if (this.y + this.radius > this.canvasHeight) {
            this.y = this.canvasHeight - this.radius;
            this.velocityY = -Math.abs(this.velocityY);
            playBounceSound();
        }
		const { hours, minutes } = getCurrentTime();
        if (this.x + this.radius < 0) {  
    player2Score += Points(minutes - player2Score);
    playScoreSound();
    this.reset();
} else if (this.x - this.radius > this.canvasWidth) {
    player1Score += Points(hours - player1Score);
    playScoreSound();
    this.reset();
}
        paddles.forEach(paddle => {
            const paddleLeft = paddle.x - paddle.width / 2;
            const paddleRight = paddle.x + paddle.width / 2;
            const paddleTop = paddle.y - paddle.height / 2;
            const paddleBottom = paddle.y + paddle.height / 2;
            if (this.x - this.radius < paddleRight &&
                this.x + this.radius > paddleLeft &&
                this.y + this.radius > paddleTop &&
                this.y - this.radius < paddleBottom) {
                let collidePoint = this.y - paddle.y;
                collidePoint = collidePoint / (paddle.height / 2);
                const angleRad = (Math.PI / 4) * collidePoint;
                this.velocityX = (paddle.x === 10 ? 1 : -1) * this.speed * Math.cos(angleRad);
                this.velocityY = this.speed * Math.sin(angleRad);
                this.speed = Math.min(this.speed + this.speedIncrement, this.speedCap);
                this.playSquareWave();
            }
        });
        if (this.x + this.radius < 0 || this.x - this.radius > this.canvasWidth) {
            this.reset();
        }
    }
    draw(ctx) {
        ctx.fillStyle = '#FFF';
        ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }
}
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const playerOne = new Paddle(10, canvas.height);
const playerTwo = new Paddle(canvas.width - 10, canvas.height);
const ball = new Ball(canvas.width, canvas.height, audioContext, source);
let previousBallX = 0;
let previousBallY = 0;
let player1Score = 0;
let player2Score = 0;
function gameLoop() {
    let paddles = [playerTwo, playerOne];
    const { hours, minutes, seconds } = getCurrentTime();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
	if (player1Score > 23) {
        player1Score = 0;
    }
	if (player2Score > 59) {
        player2Score = 0;
    }
    const boxWidth = 10;
    const boxHeight = 10;
    const numBoxes = Math.floor(canvas.height / (boxHeight * 2));
    for (let i = 0; i < numBoxes; i++) {
        ctx.fillStyle = '#FFF';
        ctx.fillRect(canvas.width / 2 - boxWidth / 2, i * boxHeight * 2, boxWidth, boxHeight);
    }
    ctx.font = '100px ScoreFont';
    ctx.fillStyle = '#FFF';
    ctx.textAlign = 'center';
    ctx.fillText(player1Score.toString().padStart(2, '0'), (canvas.width * 0.30), 125);
    ctx.fillText(player2Score.toString().padStart(2, '0'), (canvas.width * 0.77), 125);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.fillRect(previousBallX - ball.radius, previousBallY - ball.radius, ball.radius * 2, ball.radius * 2);
    ctx.fillStyle = '#FFF';
    ctx.fillRect(ball.x - ball.radius, ball.y - ball.radius, ball.radius * 2, ball.radius * 2);
    previousBallX = ball.x;
    previousBallY = ball.y;
    ball.update([playerOne, playerTwo]);
    ball.draw(ctx);
    playerOne.updateControlMode(hours, minutes, seconds, player1Score, player2Score);
    playerTwo.updateControlMode(hours, minutes, seconds, player1Score, player2Score);
    playerOne.predictBallPosition(ball);
    playerOne.draw(ctx);
    playerTwo.predictBallPosition(ball);
    playerTwo.draw(ctx);
    requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
